---
- name: Update repositories cache and install "wireguard" package
  when: ansible_facts['os_family'] == "Debian"
  become: yes
  apt:
    name: wireguard
    update_cache: yes

- name: install wireguard
  when: ansible_facts['os_family'] == "Archlinux"
  become: yes
  community.general.pacman:
    name: wireguard-tools
    state: present

- name: install ufw
  when: ansible_facts['os_family'] == "Archlinux" and (group_names | select('search','k3s') | list | count <= 0)
  become: yes
  community.general.pacman:
    name: ufw
    state: present

- name: Check if private key exists
  become: yes
  stat:
    path: "/etc/wireguard/privatekey"
  register: privatekey_result

- name: Generate private key
  when: not privatekey_result.stat.exists
  become: yes
  shell: wg genkey > /etc/wireguard/privatekey

- name: Check if public key exists
  become: yes
  stat:
    path: "/etc/wireguard/publickey"
  register: publickey_result

- name: Generate public key
  when: not publickey_result.stat.exists
  become: yes
  shell: wg pubkey < /etc/wireguard/privatekey > /etc/wireguard/publickey

- name: Get the public key from peers
  ignore_unreachable: yes
  become: yes
  ansible.builtin.slurp:
    src: /etc/wireguard/publickey
  register: publickeys
  loop: "{{ groups._running |difference([inventory_hostname]) }}"
  delegate_to: "{{ item }}"

- name: Get the private key
  become: yes
  ansible.builtin.slurp:
    src: /etc/wireguard/privatekey
  register: wireguard_server_privatekey

- name: ensure wg0 file exists
  become: yes
  copy:
    content: ""
    dest: "/etc/wireguard/wg0.conf"
    force: yes
    group: root
    owner: root

- name: Creating wireguard config
  become: yes
  blockinfile:
    state: present
    marker: "# {mark} ANSIBLE MANAGED {{ inventory_hostname }} WG CONFIGURATION"
    dest: "/etc/wireguard/wg0.conf"
    block: |
      [Interface]
      Address = {{ hostvars[inventory_hostname].tags.wireguard_ip }}
      PrivateKey = {{ wireguard_server_privatekey['content'] | b64decode | trim }}
      ListenPort = 51820
      MTU = 1400
      {% if (group_names | select('search','k3s') | list | count <= 0) %}
      PostUp = ufw route allow in on wg0 out on {{ ansible_default_ipv4.interface }}
      {% endif %}
      PostUp = iptables -t nat -I POSTROUTING -o {{ ansible_default_ipv4.interface }} -j MASQUERADE
      PostUp = ip6tables -t nat -I POSTROUTING -o {{ ansible_default_ipv4.interface }} -j MASQUERADE
      {% if (group_names | select('search','k3s') | list | count <= 0) %}
      PreDown = ufw route delete allow in on wg0 out on {{ ansible_default_ipv4.interface }}
      {% endif %}
      PreDown = iptables -t nat -D POSTROUTING -o {{ ansible_default_ipv4.interface }} -j MASQUERADE
      PreDown = ip6tables -t nat -D POSTROUTING -o {{ ansible_default_ipv4.interface }} -j MASQUERADE

- name: get subnet from netmask
  set_fact:
    subnet: "{{ (ansible_default_ipv4.address + '/255.255.255.0') | ansible.netcommon.ipaddr('network/prefix') }}"

- name: add wireguard peers for mesh
  when: 
  - "not '_wireguard' in group_names"
  # Peer is in same subnet or peer is server peer
  - (subnet | ansible.netcommon.network_in_usable(hostvars[item['item']]['private_ipv4_addresses'][0] | default(hostvars[item['item']].ansible_host))) or
    hostvars[item['item']]['public_dns_hostnames'][0] is defined
  become: yes
  blockinfile:
    dest: "/etc/wireguard/wg0.conf"
    state: present
    marker: "# {mark} ANSIBLE MANAGED WG {{ item['item'] }} MESH PEER"
    block: |
      [Peer]
      PublicKey = {{ item['content'] | b64decode | trim }}
      {% if subnet | ansible.netcommon.network_in_usable(hostvars[item['item']]['private_ipv4_addresses'][0] | default(hostvars[item['item']].ansible_host)) %}
      AllowedIPs = {{ hostvars[item['item']].tags.wireguard_ip }} {{ (", " + wireguard_vnet_cidr) if hostvars[item['item']]['public_dns_hostnames'][0] is defined }}
      Endpoint = {{ hostvars[item['item']]['private_ipv4_addresses'][0] | default(hostvars[item['item']].ansible_host) }}:51820
      {% elif hostvars[item['item']]['public_dns_hostnames'][0] is defined %}
      Endpoint = {{ hostvars[item['item']]['public_dns_hostnames'][0] }}:51820
      PersistentKeepalive = 25
      AllowedIPs = {{ wireguard_vnet_cidr }} {{ ', {0}'.format(remote_vnet_cidr | join(', ')) if hostvars[inventory_hostname]['tags']['wireguard_add_remote_cidrs'] else '' }}
      {% endif %}
  loop: "{{ publickeys['results'] }}"

- name: add wireguard peers to server
  become: yes
  when: "'_wireguard' in group_names and item['content'] is defined"
  blockinfile:
    dest: "/etc/wireguard/wg0.conf"
    state: present
    marker: "# {mark} ANSIBLE MANAGED WG {{ item['item'] }} SERVER PEER"
    block: |
      [Peer]
      AllowedIPs = {{ hostvars[item['item']].tags.wireguard_ip }}
      PublicKey = {{ item['content'] | b64decode | trim }}
      {% if (hostvars[item['item']]['private_ipv4_addresses'][0] | default(hostvars[item['item']].ansible_host)) | ipaddr(subnet) | ipaddr('bool') %}
      Endpoint = {{ hostvars[item['item']]['private_ipv4_addresses'][0] | default(hostvars[item['item']].ansible_host) }}:51820
      {% endif %}
  loop: "{{ publickeys['results'] }}"

- name: add mobile peers to server
  when: '"_wireguard" in group_names'
  ignore_errors: true
  become: yes
  blockinfile:
    dest: "/etc/wireguard/wg0.conf"
    state: present
    marker: "# mobile1 ANSIBLE MANAGED WG PEER"
    block: |
      [Peer]
      AllowedIPs = {{ wireguard_mobile_ip }}
      PublicKey = {{ wireguard_mobile_publickey }}

- name: allow ipv4 forward
  become: yes
  ansible.posix.sysctl:
    name: net.ipv4.ip_forward
    value: '1'
    sysctl_set: yes
    state: present
    reload: yes

- name: allow ipv6 forward
  become: yes
  ansible.posix.sysctl:
    name: net.ipv6.conf.all.forwarding
    value: '1'
    sysctl_set: yes
    state: present
    reload: yes

- name: limit ssh on ufw
  when: not (group_names | select('search','k3s') | list | count > 0)
  become: yes
  ufw:
    rule: limit
    port: ssh
    proto: tcp

- name: ufw allow wireguard
  when: not (group_names | select('search','k3s') | list | count > 0)
  become: yes
  ufw:
    rule: allow
    port: 51820
    proto: udp

- name: check if system is using systemd
  command: ps -p 1
  register: process_one

- name: enable ufw
  when: "'systemd' in process_one['stdout'] and (group_names | select('search','k3s') | list | count <= 0)"
  become: yes
  ufw:
    state: enabled
    policy: deny

- name: allow forwarding from eth0 to wg on server
  when: '"wireguard" in group_names and (group_names | select("search","k3s") | list | count <= 0)'
  become: yes
  ufw:
    rule: allow
    route: yes

- name: Make sure ufw is enabled
  become: yes
  when: "'systemd' in process_one['stdout'] and group_names | select('search','k3s') | list | count <= 0"
  ansible.builtin.systemd:
    state: started
    name: ufw
    enabled: yes

- name: Make sure wireguard is running
  become: yes
  ignore_errors: true
  when: "'systemd' in process_one['stdout'] and not 'k3s' in group_names"
  ansible.builtin.systemd:
    state: restarted
    name: wg-quick@wg0
    enabled: yes

- name: Sync wg conf
  become: yes
  ignore_errors: true
  shell: wg syncconf wg0 <(wg-quick strip wg0)
  args:
    warn: no